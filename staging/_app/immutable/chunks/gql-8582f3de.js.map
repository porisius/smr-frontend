{"version":3,"file":"gql-8582f3de.js","sources":["../../../../../../src/lib/utils/gql.ts"],"sourcesContent":["import type { OperationStore } from '@urql/svelte';\nimport { get, readable } from 'svelte/store';\nimport type { Load } from '@sveltejs/kit';\nimport { browser } from '$app/env';\nimport { gqlClient } from '$lib/stores/global';\n\n// Pretend you didn't see this file\n\nexport const loadWaitForNoFetch = (queries: { [key: string]: OperationStore }): Load => {\n  return async function () {\n    // If on the browser, initialize queries and start fetching, but instantly return out\n    if (browser) {\n      const result = Object.keys(queries).map((key) => {\n        const query = queries[key];\n\n        // Retrieve the global GQL client\n        get(gqlClient)\n          .query(query.query, query.variables, query.context)\n          .toPromise()\n          .then((data) => {\n            // Update query fields without calling set\n            query.update((value) => {\n              (value as unknown)['fetching'] = false;\n              if (data) {\n                (value as unknown)['data'] = data.data;\n                (value as unknown)['error'] = data.error;\n              }\n              return value;\n            });\n\n            // Force query to update its underlying store\n            query.set({\n              context: {\n                ...query.context,\n                updated: new Date()\n              }\n            });\n          })\n          .catch((err) => {\n            // Update query fields without calling set\n            query.update((value) => {\n              (value as unknown)['fetching'] = false;\n              (value as unknown)['data'] = undefined;\n              (value as unknown)['error'] = err;\n              return value;\n            });\n\n            // Force query to update its underlying store\n            query.set({\n              context: {\n                ...query.context,\n                updated: new Date()\n              }\n            });\n          });\n\n        // Update query fields without calling set\n        query.update((value) => {\n          (value as unknown)['fetching'] = true;\n          return value;\n        });\n\n        // Force query to update its underlying store\n        query.set({\n          context: {\n            ...query.context,\n            updated: new Date()\n          }\n        });\n\n        return [key, query];\n      });\n\n      return {\n        props: Object.fromEntries(result)\n      };\n    }\n\n    // If on SSR, block the load until all queries have returned\n    return {\n      props: Object.fromEntries(\n        await Promise.all(\n          Object.keys(queries).map((key) => {\n            const query = queries[key];\n            return get(gqlClient)\n              .query(query.query, query.variables, query.context)\n              .toPromise()\n              .then((data) => [key, readable(data)]);\n          })\n        )\n      )\n    };\n  };\n};\n"],"names":["loadWaitForNoFetch","queries","async","result","Object","keys","map","key","query","get","gqlClient","variables","context","toPromise","then","data","update","value","error","set","updated","Date","catch","err","props","fromEntries"],"mappings":"mFAQa,KAAAA,GAAsBC,GAC1BC,gBAEQ,CAAA,CACX,KAAMC,GAASC,OAAOC,KAAKJ,GAASK,IAAKC,GAAAA,CACvC,KAAMC,GAAQP,EAAQM,GAGtBE,SAAIC,CAAAA,EACDF,MAAMA,EAAMA,MAAOA,EAAMG,UAAWH,EAAMI,SAC1CC,UACAC,EAAAA,KAAMC,GAECP,CAAAA,EAAAQ,OAAQC,GACXA,GAAkB,SAAc,GAC7BF,GACDE,GAAkB,KAAUF,EAAKA,KACjCE,EAAkB,MAAWF,EAAKG,OAE9BD,EAAAA,EAITT,EAAMW,IAAI,CACRP,QAAS,CACJJ,GAAAA,EAAMI,QACTQ,QAAS,GAAIC,KAIlBC,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,MAAOC,GAEAf,CAAAA,EAAAQ,OAAQC,GACXA,GAAkB,SAAc,GAChCA,EAAkB,KAAA,OAClBA,EAAkB,MAAWM,EACvBN,EAITT,EAAAA,EAAMW,IAAI,CACRP,QAAS,CAAA,GACJJ,EAAMI,QACTQ,QAAS,GAAIC,WAMfb,EAAAQ,OAAQC,GACXA,GAAkB,SAAc,GAC1BA,EAAAA,EAITT,EAAMW,IAAI,CACRP,QAAS,CACJJ,GAAAA,EAAMI,QACTQ,QAAS,GAAIC,KAIV,CAAA,CAAA,EAAA,CAACd,EAAKC,CAGR,CAAA,CAAA,EAAA,MAAA,CACLgB,MAAOpB,OAAOqB,YAAYtB"}